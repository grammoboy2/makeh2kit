#!/bin/bash
#
# 'Make h2drumkit' by RockHopper 2013
#
# This is a Nautilus script to invoke makeh2kit. It assumes that makeh2kit is installed
# in a directory included in the PATH environment variable (e.g. /usr/bin, /usr/local/bin) 
# and that xterm is available.
#
# This script is public domain and provided 'as-is', without any express or implied 
# warranty. In no event will the author be held liable for any damages arising from 
# the use of this software.


# These variables may be modified if you need to specify the file path of makeh2kit
# or if you wish to use a different terminal emulator

MAKEH2KIT_FILEPATH="makeh2kit"
TERMINAL_COMMAND="xterm -hold -title MakeH2drumkit -font 9x15 -e"

# N.B. For a list of available fonts in xterm type: appres XTerm | grep VT100.font
##################################################################################


declare filePaths=""
declare fileType=""
declare prevFileType=""

while IFS="\n" read -r -d $'\n' filePath; do
    filePaths+="\"$filePath\" "
done < <(echo -n "$NAUTILUS_SCRIPT_SELECTED_FILE_PATHS")

while IFS="\n" read -r -d $'\n' filePath; do
    fileType="${filePath##*.}"

    if [[ $fileType != [fF][lL][aA][cC] ]] && [[ $fileType != [wW][aA][vV] ]] && \
       [[ $fileType != [aA][uU] ]] && [[ $fileType != [aA][iI][fF][fF] ]] && [[ $fileType != [sS][fF][zZ] ]]; then
        fileType=""
    fi

    if [ "$prevFileType" != "" ] && [ "$fileType" != "$prevFileType" ]; then
        fileType=""
        break
    fi
    prevFileType="$fileType"
done < <(echo -n "$NAUTILUS_SCRIPT_SELECTED_FILE_PATHS")

commandToExec='function setTextColour { tput setf $1; }; let CYAN=3; let RED=4; let YELLOW=6; let WHITE=7; '
commandToExec+='function startUnderline { tput smul; }; function stopUnderline { tput rmul; }; '
commandToExec+='function moveCursorUpOneLine { tput cuu1; }; '

commandToExec+='setTextColour $YELLOW; startUnderline; echo -e "\nMake h2drumkit\n"; stopUnderline; setTextColour $WHITE; '

commandToExec+='echo -e "This script will auto-generate a .h2drumkit file from the selected file(s).\nIf no files are selected it will scan the current directory for compatible\nfiles (flac, wav, au, aiff, or sfz).\n\nAudio files can be treated as indiviual instruments or as instrument layers\ngrouped either by sub-directory or by file name with numeric prefixes/suffixes\nindicating the layers.\n\nHydrogen kits can also be created from SFZ drum kits. The resulting kit will\nnot contain any audio files and will instead map the MIDI note numbers of\neach instrument in the SFZ kit (connect Hydrogen MIDI Out -> sampler MIDI In).\n"; '
commandToExec+='setTextColour $YELLOW; echo -e "Please enter the following details or simply press enter to accept the\ndefault values...\n"; setTextColour $WHITE; '

if [[ $fileType != [sS][fF][zZ] ]]; then
    commandToExec+='echo "Drumkit name (default is name of current directory, \"${PWD##*/}\"):"; setTextColour $CYAN; read -e kitName; '
    commandToExec+='if [[ $kitName == "" ]]; then kitName="${PWD##*/}"; moveCursorUpOneLine; echo $kitName; fi; setTextColour $WHITE; '
fi

commandToExec+='echo "Author:"; setTextColour $CYAN; read -e kitAuthor; setTextColour $WHITE; '

commandToExec+='echo "License:"; setTextColour $CYAN; read -e kitLicense; setTextColour $WHITE; '

commandToExec+='echo "Info (HTML formatting tags allowed):"; setTextColour $CYAN; read -e kitInfo; setTextColour $WHITE; '

if [ "$fileType" != "" ]; then
    commandToExec+="format='$fileType'; "
else
    commandToExec+='echo "File format (flac (default), wav, au, aiff, or sfz):"; setTextColour $CYAN; read -e format; '
    commandToExec+='if [[ $format == "" ]]; then format="flac"; moveCursorUpOneLine; echo $format; fi; setTextColour $WHITE; '
fi

commandToExec+='if [[ $format != [sS][fF][zZ] ]]; then '
commandToExec+='echo "Layer marker (none (default), dirs, prefix, or suffix; or d, p, or s):"; setTextColour $CYAN; read -e layerMarker; '
commandToExec+='if [[ $layerMarker == "" ]]; then moveCursorUpOneLine; echo "none"; fi; '
commandToExec+='if [[ $layerMarker == "none" ]]; then layerMarker=""; fi; setTextColour $WHITE; '
commandToExec+='fi; '

if [[ $fileType != [sS][fF][zZ] ]]; then
    commandToExec+='echo "Reverse sort order? (default is no):"; setTextColour $CYAN; read -e isReverseSortOn; '
    commandToExec+='if [[ $isReverseSortOn == "" ]]; then isReverseSortOn="no"; moveCursorUpOneLine; echo "$isReverseSortOn"; fi; setTextColour $WHITE; '

    commandToExec+='if [[ $isReverseSortOn == [yY] ]] || [[ $isReverseSortOn == [yY][eE][sS] ]]; then '
    commandToExec+='sortOrder="r"; '

    commandToExec+='elif [[ $isReverseSortOn == [nN] ]] || [[ $isReverseSortOn == [nN][oO] ]]; then '
    commandToExec+='sortOrder=""; '

    commandToExec+='else setTextColour $RED; echo -e "\nInvalid value: $isReverseSortOn"; exit 1; fi; '
fi

commandToExec+='echo; setTextColour $RED; '
commandToExec+="$MAKEH2KIT_FILEPATH "
commandToExec+='${kitName:+-n "$kitName"} -a "$kitAuthor" -l "$kitLicense" --hi "$kitInfo" -f "$format" ${layerMarker:+-L "$layerMarker"} ${sortOrder:+-r} '
commandToExec+="${filePaths:+-- $filePaths}; "

commandToExec+='if [ $? -eq 0 ]; then setTextColour $YELLOW; echo -e "All done!"; fi'

$TERMINAL_COMMAND "$commandToExec"
